\subsection{Decentralized Stochastic Gradient Free Frank Wolfe}
The decentralized architecture is composed of a central node, called master node, and other nodes connected to it but not to each other, called workers.
The workers are connected to the master node to read, write and exchange information.\\
In the Decentralized Stochastic Gradient Free Frank Wolfe method, the data is spread to $M$ workers and the starting point and the gradient are initialized to a null $d$-vector and a null $M \times d$ matrix, respectively.\\
The workers compute their local gradient using the I-RDSA scheme on the loss function and then apply the smoothing scheme (3).\\
When all the workers have finished their tasks, they send their results to the master node, which computes the average of the estimated gradients and send back the new iterate \mbox{\boldmath$ \delta$}$_{t+1}$, obtained from (5) and (6) with $\gamma_t = \frac{2}{t+8}$.\\
When all of the iterations are done, the algorithm returns the hystory of all the perturbations computed by the master node.

\begin{algorithm}
	\caption{Decentralized SGF FW}\label{decentralized} 
	 \textbf{Input} Dataset images $\mathbf{x}$, labels $y$, loss function $F$, number of queries $T$, number of workers $M$, image dimension $d$, tolerance $\varepsilon$, number of sampled directions $m$.\\
	 \textbf{Output} Universal perturbation's history.
	\begin{algorithmic}[1]		
		\State Initialize \mbox{\boldmath$ \delta$}$_{0} = \mathbf{0}$.
		\For {$t = 0, \dots, T-1$}
		\State Master node computes parameters required for the computation of the I-RDSA scheme: 
		{\scriptsize\[(\rho_t,c_t)_{I-RDSA} =\bigg(\frac{4}{\big(1+\frac{d}{m}\big)^{1/3}(t+8)^{2/3}}, \frac{2\sqrt{m}}{d^{3/2}(t+8)^{1/3}}\bigg)\]}
		\State For each worker $i$ compute I-RDSA:\newline Sample $\{\mathbf{z}_{j,t}\}_{j=1}^m \sim\mathcal{N}(0,\mathbb{1}_d)$ \newline
		 \[\mathbf{g}_i = \frac{1}{m} \sum_{j=1}^{m} \frac{F(\mathbf{x} + \mbox{\scriptsize\boldmath$ \delta$}_t + c_t\mathbf{z}_{j,t}, y) - F(\mathbf{x} + \mbox{\scriptsize\boldmath$ \delta$}_t, y)}{c_t}\mathbf{z}_{j,t}\]
		
		\State Workers compute \[\mathbf{g}_{i,t}= (1- \rho_t)\mathbf{g}_{i,t-1} + \rho_t\mathbf{g}_i.\]
		\State Push $\textbf{g}_{i,t}$ to the master node.
		\State Master node computes 
		\[\mathbf{g}_t = \frac{1}{M} \sum_{i=1}^{M} \mathbf{g}_{i,t}.\]
		\State Master node computes $\mathbf{v}_t = - \varepsilon sign(\mathbf{g}_t)$.
		\State Master node computes \mbox{\boldmath$ \delta$}$_t = (1-\gamma_t)\mbox{\boldmath$ \delta$}_t + \gamma_t\mathbf{v}_t$ and sends it to all nodes.
		\EndFor

	\end{algorithmic}
\end{algorithm}
